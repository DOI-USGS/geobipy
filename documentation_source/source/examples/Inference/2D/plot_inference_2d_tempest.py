"""
2D Posterior analysis of the Bayesian inference
-----------------------------------------------

All plotting in GeoBIPy can be carried out using the 3D inference class

"""

import matplotlib.pyplot as plt
import numpy as np
from geobipy import Inference2D

def create_model(model_type):
   from geobipy import StatArray, Distribution, RectilinearMesh1D, RectilinearMesh2D_stitched, Model
   n_points = 119
   zwedge = np.linspace(50.0, 1.0, n_points)
   zdeep = np.linspace(75.0, 500.0, n_points)

   resistivities = {'glacial' : np.r_[100, 10, 30],   # Glacial sediments, sands and tills
                  'saline_clay' : np.r_[100, 10, 1],    # Easier bottom target, uncommon until high salinity clay is 5-10 ish
                  'resistive_dolomites' : np.r_[50, 500, 50],   # Glacial sediments, resistive dolomites, marine shale.
                  'resistive_basement' : np.r_[100, 10, 10000],# Resistive Basement
                  'coastal_salt_water' : np.r_[1, 100, 20],    # Coastal salt water upper layer
                  'ice_over_salt_water' : np.r_[10000, 100, 1] # Antarctica glacier ice over salt water
   }
   conductivity = StatArray(1.0/resistivities[model_type], name="Conductivity", units='$\\frac{S}{m}$')

   # Create distributions for three lithology classes
   lithology_distribution = Distribution('MvLogNormal',
                                    mean=conductivity,
                                    variance=[0.5,0.5,0.5],
                                    linearSpace=True)

   x = RectilinearMesh1D(centres=StatArray(np.arange(n_points, dtype=np.float64), name='x'))
   mesh = RectilinearMesh2D_stitched(3, x=x)
   mesh.nCells[:] = 3
   mesh.y_edges[:, 1] = -zwedge
   mesh.y_edges[:, 2] = -zdeep
   mesh.y_edges[:, 3] = -np.inf
   mesh.y_edges.name, mesh.y_edges.units = 'Elevation', 'm'

   return Model(mesh=mesh, values=np.repeat(lithology_distribution.mean[None, :], n_points, 0))

#%%
def create_plots(model_type):
   #%%
   # Inference for a line of inferences
   # ++++++++++++++++++++++++++++++++++
   #
   # We can instantiate the inference handler by providing a path to the directory containing
   # HDF5 files generated by GeoBIPy.
   #
   # The InfereceXD classes are low memory.  They only read information from the HDF5 files
   # as and when it is needed.
   #
   # The first time you use these classes to create plots, expect long initial processing times.
   # I precompute expensive properties and store them in the HDF5 files for later use.

   ################################################################################
   results_2d = Inference2D(hdf5_file_path='../parallel/tempest/{}/0.0.h5'.format(model_type))

   ################################################################################
   # Plot a location map of the data point locations along the line

   ################################################################################
   # Before we start plotting cross sections, lets set some common keywords
   xAxis = 'x'
   kwargs = {
            #   "reciprocateParameter" : True, # Plot resistivity instead?
            # "vmin" : -2.0, # Set the minimum colour bar range in log space
            # "vmax" : 0.0, # Set the maximum colour bar range in log space
            "log" : 10, # I want to plot the log conductivity
         #    "equalize" : True
            "cmap" : 'jet'
            }

   results_2d.compute_mean_parameter()
   ################################################################################
   # We can show a basic cross-section of the parameter inverted for
   plt.figure(figsize=(16, 4))
   plt.suptitle(model_type)
   plt.subplot(3, 4, 1)
   true_model = create_model(model_type)
   kwargs['vmin'] = np.log10(np.min(true_model.values))
   kwargs['vmax'] = np.log10(np.max(true_model.values))

   true_model.pcolor(**kwargs)
   results_2d.plot_data_elevation(linewidth=0.3);
   results_2d.plot_elevation(linewidth=0.3);
   plt.ylim([-550, 60])

   plt.subplot(3, 4, 5)
   results_2d.plot_mean_model(**kwargs);
   results_2d.plot_data_elevation(linewidth=0.3);
   results_2d.plot_elevation(linewidth=0.3);


   # By adding the useVariance keyword, we can make regions of lower confidence more transparent
   plt.subplot(3, 4, 9)
   results_2d.plot_mean_model(use_variance=True, **kwargs);
   results_2d.plot_data_elevation(linewidth=0.3);
   results_2d.plot_elevation(linewidth=0.3);

   # # We can also choose to keep parameters above the DOI opaque.
   # results_2d.compute_doi()
   # plt.subplot(313)
   # results_2d.plot_mean_model(use_variance=True, mask_below_doi=True, **kwargs);
   # results_2d.plot_data_elevation(linewidth=0.3);
   # results_2d.plot_elevation(linewidth=0.3);

   ################################################################################
   # We can plot the parameter values that produced the highest posterior
   ax = plt.subplot(3, 4, 2)
   results_2d.plot_k_layers()

   ax = plt.subplot(3, 4, 6, sharex=ax)
   results_2d.plot_best_model(**kwargs);
   results_2d.plot_data_elevation(linewidth=0.3);
   results_2d.plot_elevation(linewidth=0.3);


   del kwargs['vmin']
   del kwargs['vmax']

   plt.subplot(3, 4, 3)
   plt.title('5%')
   results_2d.plot_percentile(percent=0.05, **kwargs)
   plt.subplot(3, 4, 7)
   plt.title('50%')
   results_2d.plot_percentile(percent=0.5, **kwargs)
   plt.subplot(3, 4, 11)
   plt.title('95%')
   results_2d.plot_percentile(percent=0.95, **kwargs)



   ################################################################################
   # Now we can start plotting some more interesting posterior properties.
   # How about the confidence?
   plt.subplot(3, 4, 4)
   results_2d.plot_confidence();
   results_2d.plot_data_elevation(linewidth=0.3);
   results_2d.plot_elevation(linewidth=0.3);

   ################################################################################
   # We can take the interface depth posterior for each data point,
   # and display an interface probability cross section
   # This posterior can be washed out, so the clim_scaling keyword lets me saturate
   # the top and bottom 0.5% of the colour range
   plt.subplot(3, 4, 8)
   plt.title('P(Interface)')
   results_2d.plot_interfaces(cmap='Greys', clim_scaling=0.5);
   results_2d.plot_data_elevation(linewidth=0.3);
   results_2d.plot_elevation(linewidth=0.3);

   plt.subplot(3, 4, 12)
   results_2d.plot_entropy(cmap='Greys', clim_scaling=0.5);
   results_2d.plot_data_elevation(linewidth=0.3);
   results_2d.plot_elevation(linewidth=0.3);

   # # ################################################################################
   # # # Pull the McMC results for a single datapoint
   # for fid in np.arange(0.0, 100.0, 15.0):
   #    results_2d.plot_inference_1d(fiducial=fid)

   # plt.show(block=True)
   plt.savefig('tempest_{}.png'.format(model_type))


if __name__ == '__main__':
   types = ['glacial', 'saline_clay', 'resistive_dolomites', 'resistive_basement', 'coastal_salt_water', 'ice_over_salt_water']

   for model in types:
      create_plots(model)
