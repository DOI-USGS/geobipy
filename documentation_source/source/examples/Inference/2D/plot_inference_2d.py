"""
2D Posterior analysis of the Bayesian inference
-----------------------------------------------

All plotting in GeoBIPy can be carried out using the 3D inference class

"""
#%%
import matplotlib.pyplot as plt
from geobipy import Inference2D
import numpy as np


#%%
# Inference for a line of inferences
# ++++++++++++++++++++++++++++++++++
#
# We can instantiate the inference handler by providing a path to the directory containing
# HDF5 files generated by GeoBIPy.
#
# The InfereceXD classes are low memory.  They only read information from the HDF5 files
# as and when it is needed.
#
# The first time you use these classes to create plots, expect long initial processing times.
# I precompute expensive properties and store them in the HDF5 files for later use.

################################################################################
results_2d = Inference2D(hdf5_file_path='../parallel/tempest/0.0.h5',
                         system_file_path="../../supplementary/data")

################################################################################
# Plot a location map of the data point locations along the line

################################################################################
# Before we start plotting cross sections, lets set some common keywords
xAxis = 'x'
kwargs = {
         #   "reciprocateParameter" : True, # Plot resistivity instead?
           "vmin" : -3.0, # Set the minimum colour bar range in log space
           "vmax" : 1.0, # Set the maximum colour bar range in log space
           "log" : 10, # I want to plot the log conductivity
        #    "equalize" : True
           "cmap" : 'jet'
           }
# sphinx_gallery_thumbnail_number = 2

################################################################################
# We can show a basic cross-section of the parameter inverted for
plt.figure(figsize=(12, 8))
plt.subplot(311)
results_2d.plot_mean_model(**kwargs);
results_2d.plot_data_elevation(linewidth=0.3);
results_2d.plot_elevation(linewidth=0.3);

# By adding the useVariance keyword, we can make regions of lower confidence more transparent
plt.subplot(312)
results_2d.plot_mean_model(use_variance=True, **kwargs);
results_2d.plot_data_elevation(linewidth=0.3);
results_2d.plot_elevation(linewidth=0.3);

# We can also choose to keep parameters above the DOI opaque.
plt.subplot(313)
results_2d.plot_mean_model(use_variance=True, mask_below_doi=True, **kwargs);
results_2d.plot_data_elevation(linewidth=0.3);
results_2d.plot_elevation(linewidth=0.3);


plt.figure(figsize=(12, 8))
plt.subplot(311)
plt.title('5%')
results_2d.plot_percentile(percent=0.05, **kwargs)
plt.subplot(312)
plt.title('50%')
results_2d.plot_percentile(percent=0.5, **kwargs)
plt.subplot(313)
plt.title('95%')
results_2d.plot_percentile(percent=0.95, **kwargs)

################################################################################
# We can plot the parameter values that produced the highest posterior
plt.figure()
ax = plt.subplot(211)
results_2d.plot_k_layers()

ax = plt.subplot(212, sharex=ax)
results_2d.plot_best_model(**kwargs);
results_2d.plot_data_elevation(linewidth=0.3);
results_2d.plot_elevation(linewidth=0.3);

################################################################################
# Now we can start plotting some more interesting posterior properties.
# How about the confidence?
plt.figure(figsize=(12, 8))
plt.subplot(311)
results_2d.plot_confidence();
results_2d.plot_data_elevation(linewidth=0.3);
results_2d.plot_elevation(linewidth=0.3);

################################################################################
# We can take the interface depth posterior for each data point,
# and display an interface probability cross section
# This posterior can be washed out, so the clim_scaling keyword lets me saturate
# the top and bottom 0.5% of the colour range
plt.subplot(312)
plt.title('P(Interface)')
results_2d.plot_interfaces(cmap='Greys', clim_scaling=0.5);
results_2d.plot_data_elevation(linewidth=0.3);
results_2d.plot_elevation(linewidth=0.3);

plt.subplot(313)
results_2d.plot_entropy(cmap='Greys', clim_scaling=0.5);
results_2d.plot_data_elevation(linewidth=0.3);
results_2d.plot_elevation(linewidth=0.3);

################################################################################
# Pull the McMC results for a single datapoint

for fid in np.arange(0.0, 100.0, 15.0):
   results_2d.plot_inference_1d(fiducial=fid)


plt.show()