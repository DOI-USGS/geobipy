
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/Datapoints/plot_resolve_datapoint.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_Datapoints_plot_resolve_datapoint.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_Datapoints_plot_resolve_datapoint.py:


Frequency domain datapoint
--------------------------

.. GENERATED FROM PYTHON SOURCE LINES 6-13

There are two ways in which to create a frequency domain datapoint,

1) :ref:`Instantiating a frequency domain data point`

2) :ref:`Obtaining a datapoint from a dataset`

Once instantiated, see :ref:`Using a frequency domain datapoint`

.. GENERATED FROM PYTHON SOURCE LINES 15-28

.. code-block:: default

    from os.path import join
    import numpy as np
    import h5py
    import matplotlib.pyplot as plt
    from geobipy import CircularLoops
    from geobipy import FdemSystem
    from geobipy import FdemData
    from geobipy import FdemDataPoint
    from geobipy import RectilinearMesh1D
    from geobipy import Model
    from geobipy import StatArray
    from geobipy import Distribution








.. GENERATED FROM PYTHON SOURCE LINES 29-37

Instantiating a frequency domain data point
+++++++++++++++++++++++++++++++++++++++++++

To instantiate a frequency domain datapoint we need to define some
characteristics of the acquisition system.

We need to define the frequencies in Hz of the transmitter,
and the geometery of the loops used for each frequency.

.. GENERATED FROM PYTHON SOURCE LINES 37-40

.. code-block:: default


    frequencies = np.asarray([380.0, 1776.0, 3345.0, 8171.0, 41020.0, 129550.0])








.. GENERATED FROM PYTHON SOURCE LINES 41-43

Transmitter positions are defined relative to the observation locations in the data
This is usually a constant offset for all data points.

.. GENERATED FROM PYTHON SOURCE LINES 43-53

.. code-block:: default

    transmitters = CircularLoops(orientation=['z','z','x','z','z','z'],
                                 moment=np.r_[1, 1, -1, 1, 1, 1],
                                 x = np.r_[0,0,0,0,0,0],
                                 y = np.r_[0,0,0,0,0,0],
                                 z = np.r_[0,0,0,0,0,0],
                                 pitch = np.r_[0,0,0,0,0,0],
                                 roll = np.r_[0,0,0,0,0,0],
                                 yaw = np.r_[0,0,0,0,0,0],
                                 radius = np.r_[1,1,1,1,1,1])








.. GENERATED FROM PYTHON SOURCE LINES 54-55

Receiver positions are defined relative to the transmitter

.. GENERATED FROM PYTHON SOURCE LINES 55-65

.. code-block:: default

    receivers = CircularLoops(orientation=['z','z','x','z','z','z'],
                                 moment=np.r_[1, 1, -1, 1, 1, 1],
                                 x = np.r_[7.91, 7.91, 9.03, 7.91, 7.91, 7.89],
                                 y = np.r_[0,0,0,0,0,0],
                                 z = np.r_[0,0,0,0,0,0],
                                 pitch = np.r_[0,0,0,0,0,0],
                                 roll = np.r_[0,0,0,0,0,0],
                                 yaw = np.r_[0,0,0,0,0,0],
                                 radius = np.r_[1,1,1,1,1,1])








.. GENERATED FROM PYTHON SOURCE LINES 66-67

Now we can instantiate the system.

.. GENERATED FROM PYTHON SOURCE LINES 67-69

.. code-block:: default

    fds = FdemSystem(frequencies, transmitters, receivers)








.. GENERATED FROM PYTHON SOURCE LINES 70-77

And use the system to instantiate a datapoint

Note the extra arguments that can be used to create the data point.
data is for any observed data one might have, while std are the estimated standard
deviations of those observed data.

Define some in-phase then quadrature data for each frequency.

.. GENERATED FROM PYTHON SOURCE LINES 77-88

.. code-block:: default

    data = np.r_[145.3, 435.8, 260.6, 875.1, 1502.7, 1516.9,
                 217.9, 412.5, 178.7, 516.5, 405.7, 255.7]

    fdp = FdemDataPoint(x=0.0, y=0.0, z=30.0, elevation=0.0,
                        data=data, std=None, predictedData=None,
                        system=fds, lineNumber=0.0, fiducial=0.0)

    # ###############################################################################
    # plt.figure()
    # _ = fdp.plot()








.. GENERATED FROM PYTHON SOURCE LINES 89-96

Obtaining a datapoint from a dataset
++++++++++++++++++++++++++++++++++++

More often than not, our observed data is stored in a file on disk.
We can read in a dataset and pull datapoints from it.

For more information about the frequency domain data set see :ref:`Frequency domain dataset`

.. GENERATED FROM PYTHON SOURCE LINES 98-99

Set some paths and file names

.. GENERATED FROM PYTHON SOURCE LINES 99-105

.. code-block:: default

    dataFolder = "..//supplementary//Data//"
    # The data file name
    dataFile = dataFolder + 'Resolve2.txt'
    # The EM system file name
    systemFile = dataFolder + 'FdemSystem2.stm'








.. GENERATED FROM PYTHON SOURCE LINES 106-109

###############################################################################
 Initialize and read an EM data set
 Prepare the dataset so that we can read a point at a time.

.. GENERATED FROM PYTHON SOURCE LINES 109-112

.. code-block:: default

    Dataset = FdemData._initialize_sequential_reading(dataFile, systemFile)
    # Get a datapoint from the file.
    fdp = Dataset._read_record()







.. GENERATED FROM PYTHON SOURCE LINES 113-124

.. code-block:: default


    # ################################################################################
    # # Initialize and read an EM data set
    # D = FdemData.read_csv(dataFile,systemFile)

    # ################################################################################
    # # Get a data point from the dataset
    # fdp = D.datapoint(0)
    # plt.figure()
    # _ = fdp.plot()








.. GENERATED FROM PYTHON SOURCE LINES 125-127

Using a datapoint
+++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 129-130

We can define a 1D layered earth model, and use it to predict some data

.. GENERATED FROM PYTHON SOURCE LINES 130-136

.. code-block:: default

    nCells = 19
    par = StatArray(np.linspace(0.01, 0.1, nCells), "Conductivity", "$\frac{S}{m}$")
    depth = StatArray(np.arange(nCells+1) * 10.0, "Depth", 'm')
    depth[-1] = np.inf
    mod = Model(mesh=RectilinearMesh1D(edges=depth), values=par)








.. GENERATED FROM PYTHON SOURCE LINES 137-138

Forward model the data

.. GENERATED FROM PYTHON SOURCE LINES 138-140

.. code-block:: default

    fdp.forward(mod)








.. GENERATED FROM PYTHON SOURCE LINES 141-148

.. code-block:: default

    plt.figure()
    plt.subplot(121)
    _ = mod.pcolor(transpose=True)
    plt.subplot(122)
    _ = fdp.plot_predicted()
    plt.tight_layout()




.. image-sg:: /examples/Datapoints/images/sphx_glr_plot_resolve_datapoint_001.png
   :alt: Frequency Domain EM Data
   :srcset: /examples/Datapoints/images/sphx_glr_plot_resolve_datapoint_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 149-150

Compute the sensitivity matrix for a given model

.. GENERATED FROM PYTHON SOURCE LINES 150-155

.. code-block:: default

    J = fdp.sensitivity(mod)

    plt.figure()
    _ = np.abs(J).pcolor(equalize=True, log=10, flipY=True)




.. image-sg:: /examples/Datapoints/images/sphx_glr_plot_resolve_datapoint_002.png
   :alt: plot resolve datapoint
   :srcset: /examples/Datapoints/images/sphx_glr_plot_resolve_datapoint_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 156-160

Attaching statistical descriptors to the datapoint
++++++++++++++++++++++++++++++++++++++++++++++++++

Set values of relative and additive error for both systems.

.. GENERATED FROM PYTHON SOURCE LINES 160-165

.. code-block:: default

    fdp.relative_error = 0.05
    fdp.additive_error = 10.0
    # Define a multivariate log normal distribution as the prior on the predicted data.
    fdp.predictedData.prior = Distribution('MvLogNormal', fdp.data[fdp.active], fdp.std[fdp.active]**2.0)








.. GENERATED FROM PYTHON SOURCE LINES 166-167

This allows us to evaluate the likelihood of the predicted data

.. GENERATED FROM PYTHON SOURCE LINES 167-171

.. code-block:: default

    print(fdp.likelihood(log=True))
    # Or the misfit
    print(fdp.dataMisfit())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    -733.5454886773897
    1367.8194588709218




.. GENERATED FROM PYTHON SOURCE LINES 172-173

Plot the misfits for a range of half space conductivities

.. GENERATED FROM PYTHON SOURCE LINES 173-178

.. code-block:: default

    plt.figure()
    _ = fdp.plotHalfSpaceResponses(-6.0, 4.0, 200)

    plt.title("Halfspace responses");




.. image-sg:: /examples/Datapoints/images/sphx_glr_plot_resolve_datapoint_003.png
   :alt: Halfspace responses
   :srcset: /examples/Datapoints/images/sphx_glr_plot_resolve_datapoint_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    Text(0.5, 1.0, 'Halfspace responses')



.. GENERATED FROM PYTHON SOURCE LINES 179-180

We can perform a quick search for the best fitting half space

.. GENERATED FROM PYTHON SOURCE LINES 180-186

.. code-block:: default

    halfspace = fdp.find_best_halfspace()
    print('Best half space conductivity is {} $S/m$'.format(halfspace.values))
    plt.figure()
    _ = fdp.plot()
    _ = fdp.plot_predicted()




.. image-sg:: /examples/Datapoints/images/sphx_glr_plot_resolve_datapoint_004.png
   :alt: Frequency Domain EM Data
   :srcset: /examples/Datapoints/images/sphx_glr_plot_resolve_datapoint_004.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Best half space conductivity is [0.097701] $S/m$




.. GENERATED FROM PYTHON SOURCE LINES 187-188

Compute the misfit between observed and predicted data

.. GENERATED FROM PYTHON SOURCE LINES 188-190

.. code-block:: default

    print(fdp.dataMisfit())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    45286.82862377462




.. GENERATED FROM PYTHON SOURCE LINES 191-193

We can attach priors to the height of the datapoint,
the relative error multiplier, and the additive error noise floor

.. GENERATED FROM PYTHON SOURCE LINES 193-201

.. code-block:: default



    # Define the distributions used as priors.
    zPrior = Distribution('Uniform', min=np.float64(fdp.z) - 2.0, max=np.float64(fdp.z) + 2.0)
    relativePrior = Distribution('Uniform', min=0.01, max=0.5)
    additivePrior = Distribution('Uniform', min=5, max=15)
    fdp.set_priors(z_prior=zPrior, relative_error_prior=relativePrior, additive_error_prior=additivePrior)








.. GENERATED FROM PYTHON SOURCE LINES 202-203

In order to perturb our solvable parameters, we need to attach proposal distributions

.. GENERATED FROM PYTHON SOURCE LINES 203-208

.. code-block:: default

    z_proposal = Distribution('Normal', mean=fdp.z, variance = 0.01)
    relativeProposal = Distribution('MvNormal', mean=fdp.relative_error, variance=2.5e-7)
    additiveProposal = Distribution('MvLogNormal', mean=fdp.additive_error, variance=1e-4)
    fdp.set_proposals(relativeProposal, additiveProposal, z_proposal=z_proposal)








.. GENERATED FROM PYTHON SOURCE LINES 209-210

With priors set we can auto generate the posteriors

.. GENERATED FROM PYTHON SOURCE LINES 210-225

.. code-block:: default

    fdp.set_posteriors()


    nCells = 19
    par = StatArray(np.linspace(0.01, 0.1, nCells), "Conductivity", "$\frac{S}{m}$")
    depth = StatArray(np.arange(nCells+1) * 10.0, "Depth", 'm')
    depth[-1] = np.inf
    mod = Model(mesh=RectilinearMesh1D(edges=depth), values=par)
    fdp.forward(mod)

    # Perturb the datapoint and record the perturbations
    for i in range(1000):
        fdp.perturb()
        fdp.update_posteriors()








.. GENERATED FROM PYTHON SOURCE LINES 226-228

Plot the posterior distributions
fig = plt.figure()

.. GENERATED FROM PYTHON SOURCE LINES 228-255

.. code-block:: default

    fdp.plot_posteriors(overlay=fdp)

    import h5py
    with h5py.File('fdp.h5', 'w') as f:
        fdp.createHdf(f, 'fdp', withPosterior=True)
        fdp.writeHdf(f, 'fdp', withPosterior=True)

    with h5py.File('fdp.h5', 'r') as f:
        fdp1 = FdemDataPoint.fromHdf(f['fdp'])

    fdp1.plot_posteriors(overlay=fdp1)

    import h5py
    with h5py.File('fdp.h5', 'w') as f:
        fdp.createHdf(f, 'fdp', withPosterior=True, add_axis=np.arange(10.0))

        for i in range(10):
            fdp.writeHdf(f, 'fdp', withPosterior=True, index=i)

    from geobipy import FdemData
    with h5py.File('fdp.h5', 'r') as f:
        fdp1 = FdemDataPoint.fromHdf(f['fdp'], index=0)
        fdp2 = FdemData.fromHdf(f['fdp'])

    fdp1.plot_posteriors(overlay=fdp1)

    plt.show()
    # %%


.. image-sg:: /examples/Datapoints/images/sphx_glr_plot_resolve_datapoint_005.png
   :alt: Frequency Domain EM Data
   :srcset: /examples/Datapoints/images/sphx_glr_plot_resolve_datapoint_005.png
   :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  9.918 seconds)


.. _sphx_glr_download_examples_Datapoints_plot_resolve_datapoint.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_resolve_datapoint.py <plot_resolve_datapoint.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_resolve_datapoint.ipynb <plot_resolve_datapoint.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
